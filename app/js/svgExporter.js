/**
 * @file Manages the creation, optimization, and exporting of SVG and HPGL files.
 * This module handles generating layered SVGs for CMYK channels and converting
 * vector data into plotter-friendly HPGL code.
 */

/**
 * A class to handle all SVG and HPGL export-related functionalities.
 * It stores SVG data for each channel, generates combined views,
 * optimizes the output, and provides download methods.
 */
class SVGExporter {
  /**
   * Initializes the SVGExporter.
   */
  constructor() {
    /**
     * An object to store the raw SVG string data for each channel (e.g., 'cyan', 'combined').
     * @type {Object.<string, string>}
     */
    this.svgData = {};
  }

  /**
   * Stores the generated SVG string for a specific channel.
   * @param {string} channel - The name of the channel (e.g., 'cyan', 'magenta').
   * @param {string} svg - The full SVG content as a string.
   */
  storeSVG(channel, svg) {
    this.svgData[channel] = svg;
  }

  /**
   * Triggers the download of an SVG file for a specified channel.
   * @param {string} channel - The channel name to download.
   */
  downloadSVG(channel) {
    const svg = this.svgData[channel];
    if (!svg) {
      console.error(`No SVG data found for channel: ${channel}`);
      return;
    }

    const optimizedSVG = this.optimizeSVG(svg, channel);
    const blob = new Blob([optimizedSVG], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `halftone-${channel}-${new Date().getTime()}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Generates a single, combined SVG file from all individual channel data.
   * This method creates a properly layered SVG where each channel is in a separate group (<g>),
   * allowing for easy editing in vector software like Adobe Illustrator or Inkscape.
   * @param {number} width - The width of the SVG canvas.
   * @param {number} height - The height of the SVG canvas.
   * @param {string[]} channels - The channels to include (e.g., ['cyan', 'magenta', ...]).
   * @param {Object.<string, string>} colors - A map of channel names to hex color codes.
   * @returns {string} The complete, layered SVG content as a string.
   */
  generateCombinedSVG(width, height, channels, colors) {
    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" color-interpolation-filters="sRGB">`;
    svg += `<title>Combined Halftone Pattern (Layered)</title>`;
    svg += `<desc>Generated by Advanced Halftone Plotter Tool. Each channel is in a separate group for easy editing.</desc>`;

    // Define styles for each layer, allowing colors to be edited easily via CSS.
    // mix-blend-mode: multiply is crucial for simulating CMYK overprinting.
    svg += `<defs><style type="text/css">`;
    svg += `.background { fill: white; }`;
    channels.forEach(channel => {
      const channelColor = colors[channel];
      svg += `.${channel}-layer { fill: ${channelColor}; stroke: ${channelColor}; mix-blend-mode: multiply; }`;
    });
    svg += `</style></defs>`;

    // Add a white background rectangle.
    svg += `<rect width="100%" height="100%" class="background"/>`;

    // Add each channel as a distinct, classed group (layer).
    channels.forEach(channel => {
      const channelSvg = this.svgData[channel];
      if (channelSvg) {
        svg += `<g id="${channel}-channel" class="${channel}-layer">`;
        svg += `<title>${channel.toUpperCase()} Channel</title>`;

        const elements = this.extractSVGElements(channelSvg);
        const enhancedElements = this.enhanceElements(elements, channel);
        svg += enhancedElements;

        svg += '</g>';
      }
    });

    svg += `<!-- Layer Info: ${channels.length} channels, Generated: ${new Date().toISOString()} -->`;
    svg += `<!-- Plotting Stats: ${this.getCombinedStats(channels)} -->`;
    svg += '</svg>';

    this.storeSVG('combined', svg);
    return svg;
  }

  /**
   * Extracts the inner elements (circles, polygons, etc.) from a full SVG string.
   * @param {string} svgString - The full SVG content.
   * @returns {string} The string of SVG elements inside the main group.
   */
  extractSVGElements(svgString) {
    const match = svgString.match(/<g[^>]*>(.*?)<\/g>/s);
    if (match && match[1]) {
      return match[1];
    }
    // Fallback for SVGs without a group tag
    const fallbackMatch = svgString.match(/<svg[^>]*>(.*?)<\/svg>/s);
    if (fallbackMatch && fallbackMatch[1]) {
      // Remove background rect and return rest
      return fallbackMatch[1].replace(/<rect[^>]*fill="white"[^>]*\/?>/, '');
    }
    return '';
  }

  /**
   * Enhances SVG elements by adding channel-specific classes and optimizing path data.
   * Color is inherited from the parent group's class, not applied inline.
   * @param {string} elements - A string of SVG elements.
   * @param {string} channel - The name of the channel.
   * @returns {string} The enhanced string of SVG elements.
   */
  enhanceElements(elements, channel) {
    let enhanced = elements;
    // Add channel-specific classes for potential advanced styling.
    enhanced = enhanced.replace(/<(circle|rect|polygon|line|path)/g, `<$1 class="${channel}-element"`);
    // Optimize path data by rounding coordinates.
    enhanced = this.optimizePathData(enhanced);
    return enhanced;
  }

  /**
   * Optimizes path data by rounding floating-point numbers to a fixed precision.
   * @param {string} svgContent - The SVG content string.
   * @returns {string} The SVG content with optimized coordinates.
   */
  optimizePathData(svgContent) {
    return svgContent.replace(/(\d+\.\d{3,})/g, (match) => parseFloat(match).toFixed(2));
  }

  /**
   * Performs basic optimizations on an SVG string to reduce file size.
   * @param {string} svg - The SVG content to optimize.
   * @param {string} [channel=''] - The channel name for metadata.
   * @returns {string} The optimized SVG string.
   */
  optimizeSVG(svg, channel = '') {
    let optimized = svg;
    optimized = optimized.replace('<svg', `<svg data-channel="${channel}" data-generated="${new Date().toISOString()}"`);
    optimized = this.optimizePathData(optimized);
    optimized = optimized.replace(/\s+/g, ' ').replace(/>\s+</g, '><');

    const originalSize = svg.length;
    const optimizedSize = optimized.length;
    const compression = ((originalSize - optimizedSize) / originalSize * 100).toFixed(1);
    optimized = optimized.replace('</svg>', `<!-- Optimized: ${compression}% smaller --></svg>`);

    return optimized.trim();
  }

  /**
   * Converts SVG data for a channel into HPGL (Hewlett-Packard Graphics Language) commands.
   * @param {string} channel - The channel to convert.
   * @returns {string|null} The generated HPGL code, or null if no data exists.
   */
  exportToHPGL(channel) {
    const svg = this.svgData[channel];
    if (!svg) return null;

    let hpgl = 'IN;SP1;'; // Initialize plotter and select pen 1.
    hpgl += `LB${channel.toUpperCase()} Channel${String.fromCharCode(3)};`; // Add a label.

    const elements = this.extractAllElements(svg);
    const sortedElements = this.sortElementsForPlotting(elements);

    sortedElements.forEach(element => {
      hpgl += this.convertElementToHPGL(element);
    });

    hpgl += 'PU;SP0;'; // Pen Up, and park the pen.
    return hpgl;
  }

  /**
   * Extracts all shape elements from an SVG string into a structured array.
   * @param {string} svg - The SVG content string.
   * @returns {object[]} An array of element objects with their types and attributes.
   */
  extractAllElements(svg) {
    const elements = [];
    const extract = (regex, type, parser) => {
      (svg.match(regex) || []).forEach(matchStr => {
        const el = parser(matchStr);
        if(el) elements.push({ type, ...el });
      });
    };

    extract(/<circle[^>]+>/g, 'circle', s => ({ cx: parseFloat(s.match(/cx="([^"]+)"/)?.[1]), cy: parseFloat(s.match(/cy="([^"]+)"/)?.[1]), r: parseFloat(s.match(/r="([^"]+)"/)?.[1]) }));
    extract(/<line[^>]+>/g, 'line', s => ({ x1: parseFloat(s.match(/x1="([^"]+)"/)?.[1]), y1: parseFloat(s.match(/y1="([^"]+)"/)?.[1]), x2: parseFloat(s.match(/x2="([^"]+)"/)?.[1]), y2: parseFloat(s.match(/y2="([^"]+)"/)?.[1]) }));
    extract(/<rect[^>]+>/g, 'rect', s => ({ x: parseFloat(s.match(/x="([^"]+)"/)?.[1]), y: parseFloat(s.match(/y="([^"]+)"/)?.[1]), width: parseFloat(s.match(/width="([^"]+)"/)?.[1]), height: parseFloat(s.match(/height="([^"]+)"/)?.[1]) }));
    extract(/<polygon[^>]+>/g, 'polygon', s => {
      const points = s.match(/points="([^"]+)"/)?.[1] || '';
      const coords = points.split(' ').map(p => {
        const [x, y] = p.split(',');
        return { x: parseFloat(x), y: parseFloat(y) };
      }).filter(c => !isNaN(c.x));
      return coords.length > 0 ? { points: coords } : null;
    });
    extract(/<path[^>]+>/g, 'path', s => ({ d: s.match(/d="([^"]+)"/)?.[1] || '' }));

    return elements;
  }

  /**
   * Sorts SVG elements to optimize plotter head travel distance.
   * @param {object[]} elements - An array of SVG element objects.
   * @returns {object[]} The sorted array of elements.
   */
  sortElementsForPlotting(elements) {
    // A simple top-to-bottom, left-to-right sort.
    return elements.sort((a, b) => {
      const aY = a.cy || a.y1 || a.y || (a.points ? a.points[0].y : 0);
      const bY = b.cy || b.y1 || b.y || (b.points ? b.points[0].y : 0);
      const aX = a.cx || a.x1 || a.x || (a.points ? a.points[0].x : 0);
      const bX = b.cx || b.x1 || b.x || (b.points ? b.points[0].x : 0);
      return aY !== bY ? aY - bY : aX - bX;
    });
  }

  /**
   * Converts a single structured element object into an HPGL command string.
   * @param {object} element - The element object.
   * @returns {string} The corresponding HPGL command string.
   */
  convertElementToHPGL(element) {
    let hpgl = '';
    const scale = 40; // HPGL plotter units per pixel.

    switch (element.type) {
      case 'circle':
        hpgl += `PU${Math.round(element.cx * scale)},${Math.round(element.cy * scale)};CI${Math.round(element.r * scale)};`;
        break;
      case 'line':
        hpgl += `PU${Math.round(element.x1 * scale)},${Math.round(element.y1 * scale)};PD${Math.round(element.x2 * scale)},${Math.round(element.y2 * scale)};`;
        break;
      case 'rect':
        const r = {x: Math.round(element.x * scale), y: Math.round(element.y * scale), w: Math.round(element.width * scale), h: Math.round(element.height * scale)};
        hpgl += `PU${r.x},${r.y};PD${r.x+r.w},${r.y};PD${r.x+r.w},${r.y+r.h};PD${r.x},${r.y+r.h};PD${r.x},${r.y};`;
        break;
      case 'polygon':
        if (element.points && element.points.length > 0) {
          const first = element.points[0];
          hpgl += `PU${Math.round(first.x * scale)},${Math.round(first.y * scale)};PD`;
          element.points.slice(1).forEach(p => { hpgl += `${Math.round(p.x * scale)},${Math.round(p.y * scale)};`; });
          hpgl += `${Math.round(first.x * scale)},${Math.round(first.y * scale)};`; // Close polygon
        }
        break;
      case 'path':
        // NOTE: Full path-to-HPGL conversion is complex and not implemented here.
        hpgl += `/* Path command not fully supported: ${element.d.substring(0, 40)}... */`;
        break;
    }
    return hpgl;
  }

  /**
   * Triggers the download of an HPGL file for a specified channel.
   * @param {string} channel - The channel name to download.
   */
  downloadHPGL(channel) {
    const hpgl = this.exportToHPGL(channel);
    if (!hpgl) {
      console.error(`No HPGL data generated for channel: ${channel}`);
      return;
    }

    const stats = this.getPlottingStats(channel);
    let header = `; Generated by Advanced Halftone Plotter Tool\n`;
    header += `; Channel: ${channel.toUpperCase()}\n`;
    header += `; Date: ${new Date().toISOString()}\n`;
    if (stats) {
      header += `; Elements: ${stats.totalElements}, Est. Time: ${stats.estimatedPlotTime}\n`;
    }
    header += `; Scale: 40 HPGL units per pixel\n\n`;

    const blob = new Blob([header + hpgl], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `halftone-${channel}-${new Date().getTime()}.hpgl`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Calculates statistics about the elements in an SVG for plotting estimates.
   * @param {string} channel - The channel to analyze.
   * @returns {object|null} An object with element counts and estimated plot time.
   */
  getPlottingStats(channel) {
    const svg = this.svgData[channel];
    if (!svg) return null;

    const elements = this.extractAllElements(svg);
    const counts = { circles: 0, lines: 0, polygons: 0, paths: 0, rects: 0 };
    elements.forEach(e => { (counts[e.type+'s']++) });

    return {
      ...counts,
      totalElements: elements.length,
      estimatedPlotTime: this.estimatePlotTime(counts.circles, counts.lines, counts.polygons + counts.paths + counts.rects)
    };
  }

  /**
   * Estimates the time required to plot a set of shapes.
   * @param {number} circles - Number of circles.
   * @param {number} lines - Number of lines.
   * @param {number} complexShapes - Number of polygons, paths, and rects.
   * @returns {string} The estimated time in MM:SS format.
   */
  estimatePlotTime(circles, lines, complexShapes) {
    const totalSeconds = (circles * 0.8) + (lines * 0.2) + (complexShapes * 1.2) + 5; // Base times + setup
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.round(totalSeconds % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  /**
   * Gets a summary string of plotting stats for all channels combined.
   * @param {string[]} channels - The channels to include in the stats.
   * @returns {string} A summary string (e.g., "12345 elements, 5:42 estimated").
   */
  getCombinedStats(channels) {
    let totalElements = 0, totalTime = 0;
    channels.forEach(channel => {
      const stats = this.getPlottingStats(channel);
      if (stats) {
        totalElements += stats.totalElements;
        const [m, s] = stats.estimatedPlotTime.split(':').map(Number);
        totalTime += m * 60 + s;
      }
    });
    const totalMinutes = Math.floor(totalTime / 60);
    const remSeconds = Math.round(totalTime % 60);
    return `${totalElements} elements, ${totalMinutes}:${remSeconds.toString().padStart(2, '0')} estimated`;
  }

  /**
   * Downloads all individual channel SVGs and the combined SVG in sequence.
   */
  async downloadAllChannels() {
    const channels = Object.keys(this.svgData).filter(k => k !== 'combined');
    let delay = 0;
    for (const channel of channels) {
      if (this.svgData[channel]) {
        setTimeout(() => this.downloadSVG(channel), delay);
        delay += 500; // Stagger downloads to prevent browser blocking.
      }
    }
    if (this.svgData.combined) {
      setTimeout(() => this.downloadSVG('combined'), delay);
    }
  }
}

window.SVGExporter = SVGExporter;