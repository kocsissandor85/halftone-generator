/**
 * Enhanced SVG export utilities with advanced pattern optimization
 */

class SVGExporter {
  constructor() {
    this.svgData = {};
  }

  /**
   * Store SVG data for a channel
   */
  storeSVG(channel, svg) {
    this.svgData[channel] = svg;
  }

  /**
   * Download SVG file with enhanced metadata
   */
  downloadSVG(channel) {
    const svg = this.svgData[channel];
    if (!svg) {
      console.error(`No SVG data found for channel: ${channel}`);
      return;
    }

    const optimizedSVG = this.optimizeSVG(svg, channel);
    const blob = new Blob([optimizedSVG], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `halftone-${channel}-${new Date().getTime()}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Generate combined SVG from all channels with advanced blending
   */
  generateCombinedSVG(width, height, channels = ['cyan', 'magenta', 'yellow', 'black']) {
    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

    // Add metadata
    svg += `<title>Combined CMYK Halftone Pattern</title>`;
    svg += `<desc>Generated by Advanced Halftone Plotter Tool at ${new Date().toISOString()}</desc>`;

    // Add definitions for advanced features
    svg += `<defs>`;

    // Add gradients for smooth blending
    channels.forEach((channel, index) => {
      const channelColor = document.getElementById(channel + 'Color').value;
      svg += `<linearGradient id="${channel}Gradient" x1="0%" y1="0%" x2="100%" y2="100%">`;
      svg += `<stop offset="0%" style="stop-color:${channelColor};stop-opacity:0.8" />`;
      svg += `<stop offset="100%" style="stop-color:${channelColor};stop-opacity:0.6" />`;
      svg += `</linearGradient>`;
    });

    // Add filters for advanced effects
    svg += `<filter id="multiply" x="0%" y="0%" width="100%" height="100%">`;
    svg += `<feBlend mode="multiply"/>`;
    svg += `</filter>`;

    svg += `</defs>`;

    // Background
    svg += `<rect width="${width}" height="${height}" fill="white"/>`;

    // Add each channel as a group with enhanced properties
    channels.forEach((channel, index) => {
      const channelSvg = this.svgData[channel];
      if (channelSvg) {
        const channelColor = document.getElementById(channel + 'Color').value;

        svg += `<g id="${channel}Channel" style="mix-blend-mode: multiply;" opacity="0.85">`;
        svg += `<title>${channel.toUpperCase()} Channel</title>`;

        // Extract elements from channel SVG with enhanced processing
        const elements = this.extractSVGElements(channelSvg);
        const enhancedElements = this.enhanceElements(elements, channelColor, channel);
        svg += enhancedElements;

        svg += '</g>';
      }
    });

    // Add layer information as comments
    svg += `<!-- Layer Information: ${channels.length} channels -->`;
    svg += `<!-- Generated: ${new Date().toISOString()} -->`;
    svg += `<!-- Pattern Statistics: ${this.getCombinedStats()} -->`;

    svg += '</svg>';
    this.svgData.combined = svg;
    return svg;
  }

  /**
   * Enhanced element extraction with pattern recognition
   */
  extractSVGElements(svgString) {
    // Extract the main group content, preserving all attributes
    const match = svgString.match(/<g[^>]*>(.*?)<\/g>/s);
    if (match) {
      return match[1];
    }

    // Fallback: extract everything between the SVG wrapper
    const fallbackMatch = svgString.match(/<svg[^>]*>(.*?)<\/svg>/s);
    if (fallbackMatch) {
      // Remove background rect and return rest
      return fallbackMatch[1].replace(/<rect[^>]*fill="white"[^>]*\/?>/, '');
    }

    return '';
  }

  /**
   * Enhance elements with advanced SVG features
   */
  enhanceElements(elements, color, channel) {
    let enhanced = elements;

    // Replace generic color references with channel-specific colors
    enhanced = enhanced.replace(/fill="[^"]*"/g, `fill="${color}"`);
    enhanced = enhanced.replace(/stroke="currentColor"/g, `stroke="${color}"`);

    // Add channel-specific classes for CSS styling
    enhanced = enhanced.replace(/<(circle|rect|polygon|line|path)/g, `<$1 class="${channel}-element"`);

    // Optimize path data for better compression
    enhanced = this.optimizePathData(enhanced);

    return enhanced;
  }

  /**
   * Optimize path data for smaller file sizes
   */
  optimizePathData(svgContent) {
    // Round coordinates to reduce precision where not needed
    return svgContent.replace(/(\d+\.\d{3,})/g, (match) => {
      return parseFloat(match).toFixed(2);
    });
  }

  /**
   * Advanced SVG optimization with pattern-aware compression
   */
  optimizeSVG(svg, channel = '') {
    let optimized = svg;

    // Add metadata
    optimized = optimized.replace('<svg',
      `<svg data-channel="${channel}" data-generated="${new Date().toISOString()}"`);

    // Optimize coordinates
    optimized = optimized.replace(/(\d+\.\d{3,})/g, (match) =>
      parseFloat(match).toFixed(2));

    // Remove unnecessary whitespace but preserve readability
    optimized = optimized.replace(/\s+/g, ' ');
    optimized = optimized.replace(/>\s+</g, '><');

    // Optimize repeated patterns
    optimized = this.optimizeRepeatedPatterns(optimized);

    // Add compression statistics as comment
    const originalSize = svg.length;
    const optimizedSize = optimized.length;
    const compression = ((originalSize - optimizedSize) / originalSize * 100).toFixed(1);

    optimized = optimized.replace('</svg>',
      `<!-- Optimized: ${compression}% smaller (${originalSize} → ${optimizedSize} bytes) --></svg>`);

    return optimized.trim();
  }

  /**
   * Optimize repeated patterns using SVG definitions
   */
  optimizeRepeatedPatterns(svg) {
    // Find repeated circle patterns
    const circles = svg.match(/<circle[^>]+>/g) || [];
    const circleGroups = {};

    circles.forEach(circle => {
      const radius = circle.match(/r="([^"]+)"/)?.[1];
      if (radius) {
        if (!circleGroups[radius]) circleGroups[radius] = [];
        circleGroups[radius].push(circle);
      }
    });

    // If we have many circles of the same radius, use <use> elements
    Object.keys(circleGroups).forEach(radius => {
      if (circleGroups[radius].length > 10) {
        // Could implement <defs> and <use> optimization here
        // For now, keep simple approach
      }
    });

    return svg;
  }

  /**
   * Enhanced HPGL export with pattern-specific optimizations
   */
  exportToHPGL(channel) {
    const svg = this.svgData[channel];
    if (!svg) return null;

    let hpgl = 'IN;SP1;'; // Initialize, select pen 1

    // Add header with metadata
    hpgl += `LB${channel.toUpperCase()} Channel${String.fromCharCode(3)};`;

    // Extract and convert different elements based on pattern type
    const elements = this.extractAllElements(svg);

    // Sort elements by type for optimal plotting order
    const sortedElements = this.sortElementsForPlotting(elements);

    sortedElements.forEach(element => {
      hpgl += this.convertElementToHPGL(element);
    });

    hpgl += 'PU;SP0;'; // Pen up, select pen 0 (park)
    return hpgl;
  }

  /**
   * Extract all SVG elements with their types and attributes
   */
  extractAllElements(svg) {
    const elements = [];

    // Extract circles
    const circles = svg.match(/<circle[^>]+>/g) || [];
    circles.forEach(circle => {
      const cx = parseFloat(circle.match(/cx="([^"]+)"/)?.[1] || 0);
      const cy = parseFloat(circle.match(/cy="([^"]+)"/)?.[1] || 0);
      const r = parseFloat(circle.match(/r="([^"]+)"/)?.[1] || 0);
      elements.push({ type: 'circle', cx, cy, r });
    });

    // Extract lines
    const lines = svg.match(/<line[^>]+>/g) || [];
    lines.forEach(line => {
      const x1 = parseFloat(line.match(/x1="([^"]+)"/)?.[1] || 0);
      const y1 = parseFloat(line.match(/y1="([^"]+)"/)?.[1] || 0);
      const x2 = parseFloat(line.match(/x2="([^"]+)"/)?.[1] || 0);
      const y2 = parseFloat(line.match(/y2="([^"]+)"/)?.[1] || 0);
      elements.push({ type: 'line', x1, y1, x2, y2 });
    });

    // Extract polygons
    const polygons = svg.match(/<polygon[^>]+>/g) || [];
    polygons.forEach(polygon => {
      const points = polygon.match(/points="([^"]+)"/)?.[1] || '';
      const coords = points.split(' ').map(point => {
        const [x, y] = point.split(',');
        return { x: parseFloat(x), y: parseFloat(y) };
      }).filter(coord => !isNaN(coord.x) && !isNaN(coord.y));
      if (coords.length > 0) {
        elements.push({ type: 'polygon', points: coords });
      }
    });

    // Extract paths
    const paths = svg.match(/<path[^>]+>/g) || [];
    paths.forEach(path => {
      const d = path.match(/d="([^"]+)"/)?.[1] || '';
      elements.push({ type: 'path', d });
    });

    // Extract rectangles
    const rects = svg.match(/<rect[^>]+>/g) || [];
    rects.forEach(rect => {
      const x = parseFloat(rect.match(/x="([^"]+)"/)?.[1] || 0);
      const y = parseFloat(rect.match(/y="([^"]+)"/)?.[1] || 0);
      const width = parseFloat(rect.match(/width="([^"]+)"/)?.[1] || 0);
      const height = parseFloat(rect.match(/height="([^"]+)"/)?.[1] || 0);
      if (width > 0 && height > 0) {
        elements.push({ type: 'rect', x, y, width, height });
      }
    });

    return elements;
  }

  /**
   * Sort elements for optimal plotting order
   */
  sortElementsForPlotting(elements) {
    // Group by type and sort by position for minimal pen travel
    const grouped = {
      circles: elements.filter(e => e.type === 'circle'),
      lines: elements.filter(e => e.type === 'line'),
      polygons: elements.filter(e => e.type === 'polygon'),
      paths: elements.filter(e => e.type === 'path'),
      rects: elements.filter(e => e.type === 'rect')
    };

    // Sort each group by position (top-left to bottom-right)
    Object.keys(grouped).forEach(type => {
      grouped[type].sort((a, b) => {
        const aY = a.cy || a.y1 || a.y || (a.points ? a.points[0].y : 0);
        const bY = b.cy || b.y1 || b.y || (b.points ? b.points[0].y : 0);
        const aX = a.cx || a.x1 || a.x || (a.points ? a.points[0].x : 0);
        const bX = b.cx || b.x1 || b.x || (b.points ? b.points[0].x : 0);

        return aY !== bY ? aY - bY : aX - bX;
      });
    });

    // Return in optimal plotting order: points first, then lines, then complex shapes
    return [
      ...grouped.circles,
      ...grouped.lines,
      ...grouped.rects,
      ...grouped.polygons,
      ...grouped.paths
    ];
  }

  /**
   * Convert individual element to HPGL commands
   */
  convertElementToHPGL(element) {
    let hpgl = '';
    const scale = 40; // HPGL units per pixel (1016 units per inch / 25.4 pixels per inch ≈ 40)

    switch (element.type) {
      case 'circle':
        const hpglX = Math.round(element.cx * scale);
        const hpglY = Math.round(element.cy * scale);
        const hpglR = Math.round(element.r * scale);
        hpgl += `PU${hpglX},${hpglY};CI${hpglR};`;
        break;

      case 'line':
        const x1 = Math.round(element.x1 * scale);
        const y1 = Math.round(element.y1 * scale);
        const x2 = Math.round(element.x2 * scale);
        const y2 = Math.round(element.y2 * scale);
        hpgl += `PU${x1},${y1};PD${x2},${y2};`;
        break;

      case 'rect':
        const rx = Math.round(element.x * scale);
        const ry = Math.round(element.y * scale);
        const rw = Math.round(element.width * scale);
        const rh = Math.round(element.height * scale);
        // Draw rectangle as connected lines
        hpgl += `PU${rx},${ry};PD${rx + rw},${ry};PD${rx + rw},${ry + rh};PD${rx},${ry + rh};PD${rx},${ry};`;
        break;

      case 'polygon':
        if (element.points && element.points.length > 0) {
          const firstPoint = element.points[0];
          hpgl += `PU${Math.round(firstPoint.x * scale)},${Math.round(firstPoint.y * scale)};PD`;

          element.points.slice(1).forEach(point => {
            hpgl += `${Math.round(point.x * scale)},${Math.round(point.y * scale)};`;
          });

          // Close the polygon
          hpgl += `${Math.round(firstPoint.x * scale)},${Math.round(firstPoint.y * scale)};`;
        }
        break;

      case 'path':
        // Simplified path conversion (would need more complex parsing for full SVG path support)
        hpgl += `/* Path: ${element.d.substring(0, 50)}... */`;
        break;
    }

    return hpgl;
  }

  /**
   * Download HPGL file with enhanced metadata
   */
  downloadHPGL(channel) {
    const hpgl = this.exportToHPGL(channel);
    if (!hpgl) {
      console.error(`No HPGL data generated for channel: ${channel}`);
      return;
    }

    // Add header comments
    const timestamp = new Date().toISOString();
    const stats = this.getPlottingStats(channel);
    let headerComments = `;Generated by Advanced Halftone Plotter Tool\n`;
    headerComments += `;Channel: ${channel.toUpperCase()}\n`;
    headerComments += `;Date: ${timestamp}\n`;
    if (stats) {
      headerComments += `;Elements: ${stats.totalElements}\n`;
      headerComments += `;Estimated time: ${stats.estimatedPlotTime}\n`;
    }
    headerComments += `;Scale: 40 HPGL units per pixel\n\n`;

    const finalHpgl = headerComments + hpgl;

    const blob = new Blob([finalHpgl], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `halftone-${channel}-${new Date().getTime()}.hpgl`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Generate enhanced plotting statistics
   */
  getPlottingStats(channel) {
    const svg = this.svgData[channel];
    if (!svg) return null;

    const elements = this.extractAllElements(svg);
    const circles = elements.filter(e => e.type === 'circle').length;
    const lines = elements.filter(e => e.type === 'line').length;
    const polygons = elements.filter(e => e.type === 'polygon').length;
    const paths = elements.filter(e => e.type === 'path').length;
    const rects = elements.filter(e => e.type === 'rect').length;

    return {
      circles,
      lines,
      polygons,
      paths,
      rectangles: rects,
      totalElements: elements.length,
      estimatedPlotTime: this.estimatePlotTime(circles, lines, polygons + paths + rects)
    };
  }

  /**
   * Enhanced plot time estimation
   */
  estimatePlotTime(circles, lines, complexShapes) {
    // More accurate time estimates based on actual plotter performance
    const circleTime = circles * 0.8; // Circles take longer due to curves
    const lineTime = lines * 0.2; // Simple lines are fastest
    const complexTime = complexShapes * 1.2; // Polygons and paths take longer
    const setupTime = 5; // Setup and pen changes

    const totalSeconds = circleTime + lineTime + complexTime + setupTime;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.round(totalSeconds % 60);

    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  /**
   * Get combined statistics for all channels
   */
  getCombinedStats() {
    const channels = ['cyan', 'magenta', 'yellow', 'black'];
    let totalElements = 0;
    let totalTime = 0;

    channels.forEach(channel => {
      const stats = this.getPlottingStats(channel);
      if (stats) {
        totalElements += stats.totalElements;
        const [minutes, seconds] = stats.estimatedPlotTime.split(':');
        totalTime += parseInt(minutes) * 60 + parseInt(seconds);
      }
    });

    const totalMinutes = Math.floor(totalTime / 60);
    const remainingSeconds = totalTime % 60;

    return `${totalElements} elements, ${totalMinutes}:${remainingSeconds.toString().padStart(2, '0')} estimated`;
  }

  /**
   * Export all channels as individual files with staggered download
   */
  async downloadAllChannels() {
    const channels = ['cyan', 'magenta', 'yellow', 'black'];
    let downloadCount = 0;

    for (const channel of channels) {
      if (this.svgData[channel]) {
        setTimeout(() => {
          this.downloadSVG(channel);
        }, downloadCount * 500); // 500ms delay between downloads
        downloadCount++;
      }
    }

    // Download combined version last
    if (this.svgData.combined) {
      setTimeout(() => {
        this.downloadSVG('combined');
      }, downloadCount * 500);
    }
  }

  /**
   * Export to additional formats (G-code, DXF, etc.)
   */
  exportToGCode(channel) {
    const elements = this.extractAllElements(this.svgData[channel]);
    let gcode = '; G-code generated by Advanced Halftone Plotter Tool\n';
    gcode += '; Channel: ' + channel.toUpperCase() + '\n';
    gcode += 'G21 ; Set units to millimeters\n';
    gcode += 'G90 ; Absolute positioning\n';
    gcode += 'G1 F3000 ; Set feed rate\n';

    elements.forEach(element => {
      switch (element.type) {
        case 'circle':
          // Convert circle to G-code arc
          gcode += `G0 X${element.cx.toFixed(2)} Y${element.cy.toFixed(2)}\n`;
          gcode += `G2 I${element.r.toFixed(2)} J0\n`;
          break;
        case 'line':
          gcode += `G0 X${element.x1.toFixed(2)} Y${element.y1.toFixed(2)}\n`;
          gcode += `G1 X${element.x2.toFixed(2)} Y${element.y2.toFixed(2)}\n`;
          break;
      }
    });

    gcode += 'M30 ; End program\n';
    return gcode;
  }
}

// Export for use in main.js
window.SVGExporter = SVGExporter;