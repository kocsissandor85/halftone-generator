/**
 * @file Manages the creation, optimization, and exporting of SVG files.
 * This module handles generating layered SVGs for color separated channels.
 */

/**
 * A class to handle all SVG export-related functionalities.
 * It stores SVG data for each channel, generates combined views,
 * optimizes the output, and provides download methods.
 */
class SVGExporter {
  /**
   * Initializes the SVGExporter.
   */
  constructor() {
    /**
     * An object to store the raw SVG string data for each channel (e.g., 'cyan', 'combined').
     * @type {Object.<string, string>}
     */
    this.svgData = {};
    /**
     * A store for paper size definitions.
     * @type {Object.<string, object>}
     */
    this.paperSizes = {
      'image': { width: null, height: null, unit: 'px', margin: 0 },
      'a4': { width: 210, height: 297, unit: 'mm', margin: 10 },
      'a3': { width: 297, height: 420, unit: 'mm', margin: 10 },
      'letter': { width: 8.5, height: 11, unit: 'in', margin: 0.25 },
      'tabloid': { width: 11, height: 17, unit: 'in', margin: 0.5 },
    };
  }

  /**
   * Stores the generated SVG string for a specific channel.
   * @param {string} channel - The name of the channel (e.g., 'cyan', 'magenta').
   * @param {string} svg - The full SVG content as a string.
   */
  storeSVG(channel, svg) {
    this.svgData[channel] = svg;
  }

  /**
   * Triggers the download of an SVG file for a specified channel.
   * @param {string} channel - The channel name to download.
   * @param {object} [config={}] - The application configuration, including paper size.
   */
  downloadSVG(channel, config = {}) {
    let svgContent = this.svgData[channel];
    if (!svgContent) {
      console.error(`No SVG data found for channel: ${channel}`);
      return;
    }

    // If a paper size is selected, re-format the SVG.
    if (config.paperSize && config.paperSize !== 'image' && channel === 'combined') {
      svgContent = this.formatSVGForPaper(svgContent, config);
    }

    const optimizedSVG = this.optimizeSVG(svgContent, channel);
    const blob = new Blob([optimizedSVG], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `halftone-${channel}-${new Date().getTime()}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Generates a single, combined SVG file from all individual channel data.
   * This method creates a properly layered SVG where each channel is in a separate group (<g>),
   * allowing for easy editing in vector software like Adobe Illustrator or Inkscape.
   * @param {number} width - The width of the SVG canvas.
   * @param {number} height - The height of the SVG canvas.
   * @param {string[]} channels - The channels to include (e.g., ['cyan', 'magenta', ...]).
   * @param {Object.<string, string>} colors - A map of channel names to hex color codes.
   * @returns {string} The complete, layered SVG content as a string.
   */
  generateCombinedSVG(width, height, channels, colors) {
    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" color-interpolation-filters="sRGB">`;
    svg += `<title>Combined Halftone Pattern (Layered)</title>`;
    svg += `<desc>Generated by Advanced Halftone Plotter Tool. Each channel is in a separate group for easy editing.</desc>`;

    // Define styles for each layer, allowing colors to be edited easily via CSS.
    // mix-blend-mode: multiply is crucial for simulating CMYK overprinting.
    svg += `<defs><style type="text/css">`;
    svg += `.background { fill: white; }`;
    channels.forEach(channel => {
      const channelColor = colors[channel];
      svg += `.${channel}-layer { fill: ${channelColor}; stroke: ${channelColor}; mix-blend-mode: multiply; }`;
    });
    svg += `</style></defs>`;

    // Add a white background rectangle.
    svg += `<rect width="100%" height="100%" class="background"/>`;

    // Add each channel as a distinct, classed group (layer).
    channels.forEach(channel => {
      const channelSvg = this.svgData[channel];
      if (channelSvg) {
        // Extract only the inner <g> content from the worker-generated SVG
        const gMatch = channelSvg.match(/<g[^>]*>(.*?)<\/g>/s);
        const elements = gMatch ? gMatch[1] : '';

        svg += `<g id="${channel}-channel" class="${channel}-layer">`;
        svg += `<title>${channel.toUpperCase()} Channel</title>`;
        svg += this.optimizePathData(elements);
        svg += '</g>';
      }
    });

    svg += `<!-- Layer Info: ${channels.length} channels, Generated: ${new Date().toISOString()} -->`;
    svg += '</svg>';

    this.storeSVG('combined', svg);
    return svg;
  }

  /**
   * Extracts the inner elements (circles, polygons, etc.) from a full SVG string.
   * @param {string} svgString - The full SVG content.
   * @returns {string} The string of SVG elements inside the main group.
   */
  extractSVGElements(svgString) {
    const match = svgString.match(/<svg[^>]*>(.*?)<\/svg>/s);
    if (match && match[1]) {
      // Return everything inside the <svg> tag.
      return match[1];
    }
    return '';
  }

  /**
   * Optimizes path data by rounding floating-point numbers to a fixed precision.
   * @param {string} svgContent - The SVG content string.
   * @returns {string} The SVG content with optimized coordinates.
   */
  optimizePathData(svgContent) {
    // This regex rounds any floating point number with 3 or more decimal places to 2.
    return svgContent.replace(/(\d+\.\d{3,})/g, (match) => parseFloat(match).toFixed(2));
  }

  /**
   * Performs basic optimizations on an SVG string to reduce file size.
   * @param {string} svg - The SVG content to optimize.
   * @param {string} [channel=''] - The channel name for metadata.
   * @returns {string} The optimized SVG string.
   */
  optimizeSVG(svg, channel = '') {
    let optimized = svg;
    // Add metadata
    optimized = optimized.replace('<svg', `<svg data-channel="${channel}" data-generated="${new Date().toISOString()}"`);
    // Round coordinates
    optimized = this.optimizePathData(optimized);
    // Remove extra whitespace
    optimized = optimized.replace(/\s+/g, ' ').replace(/>\s+</g, '><');

    const originalSize = svg.length;
    const optimizedSize = optimized.length;
    const compression = ((originalSize - optimizedSize) / originalSize * 100).toFixed(1);

    // Add optimization comment
    if (compression > 0) {
      optimized = optimized.replace('</svg>', `<!-- Optimized: ${compression}% smaller --></svg>`);
    }

    return optimized.trim();
  }

  /**
   * Downloads all individual channel SVGs and the combined SVG in sequence.
   * @param {object} [config={}] - The application configuration.
   */
  async downloadAllChannels(config = {}) {
    const channels = Object.keys(this.svgData).filter(k => k !== 'combined');
    let delay = 0;
    for (const channel of channels) {
      if (this.svgData[channel]) {
        setTimeout(() => this.downloadSVG(channel, config), delay);
        delay += 500; // Stagger downloads to prevent browser blocking.
      }
    }
    if (this.svgData.combined) {
      setTimeout(() => this.downloadSVG('combined', config), delay);
    }
  }

  /**
   * Wraps an existing SVG inside a new SVG formatted for a specific paper size.
   * @param {string} svgContent - The original SVG content string.
   * @param {object} config - The application configuration.
   * @returns {string} The new SVG string formatted for the paper size.
   */
  formatSVGForPaper(svgContent, config) {
    const paper = this.paperSizes[config.paperSize];
    if (!paper) return svgContent;

    const imageWidth = parseFloat(svgContent.match(/width="([^"]+)"/)?.[1]);
    const imageHeight = parseFloat(svgContent.match(/height="([^"]+)"/)?.[1]);
    if (!imageWidth || !imageHeight) return svgContent;

    const paperWidth = paper.width;
    const paperHeight = paper.height;
    const margin = paper.margin;

    const safeWidth = paperWidth - 2 * margin;
    const safeHeight = paperHeight - 2 * margin;

    const scale = Math.min(safeWidth / imageWidth, safeHeight / imageHeight);
    const scaledWidth = imageWidth * scale;
    const scaledHeight = imageHeight * scale;

    const xOffset = margin + (safeWidth - scaledWidth) / 2;
    const yOffset = margin + (safeHeight - scaledHeight) / 2;

    const innerSVG = this.extractSVGElements(svgContent);

    let wrapperSVG = `<svg width="${paperWidth}${paper.unit}" height="${paperHeight}${paper.unit}" viewBox="0 0 ${paperWidth} ${paperHeight}" xmlns="http://www.w3.org/2000/svg" color-interpolation-filters="sRGB">`;
    wrapperSVG += `<title>Halftone for ${config.paperSize.toUpperCase()} Paper</title>`;
    wrapperSVG += `<desc>Content scaled to fit within a ${margin}${paper.unit} margin.</desc>`;
    wrapperSVG += `<g transform="translate(${xOffset.toFixed(3)} ${yOffset.toFixed(3)}) scale(${scale.toFixed(5)})">`;
    wrapperSVG += innerSVG;
    wrapperSVG += `</g></svg>`;

    return wrapperSVG;
  }
}

// Attach to the global scope to be accessible by other scripts
self.SVGExporter = SVGExporter;